job-service.url = http://localhost:8082
company-service.url = http://localhost:8081
review-service.url = http://localhost:8083

spring.application.name= job-ms
server.port=8082

#spring.h2.console.enabled = true
## Here we are using test database.
#spring.datasource.url = jdbc:h2:mem:test
#spring.jpa.generate-ddl=true
## to log sql queries generated by hibernate into console.
#spring.jpa.show-sql=true
##Instead of creating and dropping schema everytime, we can update it.
#spring.jpa.hibernate.ddl-auto=update


# PostgreSQL
spring.datasource.url=jdbc:postgresql://localhost:5432/job
spring.datasource.username=user
spring.datasource.password=password
spring.jpa.database=POSTGRESQL
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto = update
#  create-drop
#This tells hiberanate which dilect should use.
#dialect is a configuration of SQL generation and it varies from database to database.
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

#Eureka
eureka.client.serviceUrl.defaultZone = http://localhost:8761/eureka/
# Below property tells, whether you need this application to register to Eureka,
# here we specify it as true bcz we need to register this microservice with Eureka.
eureka.client.register-with-eureka = true
# Below property tells, does this application needs to fetch the information of the registry.
eureka.client.fetch-registry = true

#Zipkin
# We are telling Zipkin to trace each and every request, that goes on.
# In production grade environment, we might not want to trace all requests flowing
#in our system, because it will slow down our application, so we will reduce to 0.6,
#so that it will trace 60% of the request.
management.tracing.sampling.probability = 1.0

#Config Server
#Here we are saying spring boot application to import the configurations from configserver.
#Here we can make the below property optional, this will be helpful in cases like,
#if the config server is unavailable, it don't through any I/O errors,
#instead it uses local application.properties file.
spring.config.import=optional:configserver:http://localhost:8080
spring.profiles.active=default

#Actuator configuration
# This will enables the healthcheck for circuit breakers in the actuator..
management.health.circuitbreakers.enabled=true
# This is exposing the health endpoint, in the actuator.
management.endpoints.web.exposure.include = health
# This is adding lot more details(count of incoming requests, count of successful/failure requests.) to health endpoint.
management.endpoint.health.show-details = always

#Resilience4J
#Here, companyBreaker is the circuitbreaker instance, that we are creating and is being registered
#in Health Indicator, this can be accessed via health endpoint in actuator configurations.
resilience4j.circuitbreaker.instances.companyBreaker.registerHealthIndicator=true

#slidingWindowSize defines, the no.of calls stored in the sliding window of the circuit breaker.
#generally used to calculate the failure rate %.
resilience4j.circuitbreaker.instances.companyBreaker.slidingWindowSize=10

#It defines no.of call can be recorded, before the circuitbreaker can calculate the failure rate.
resilience4j.circuitbreaker.instances.companyBreaker.minimumNumberOfCalls=5

resilience4j.circuitbreaker.instances.companyBreaker.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.companyBreaker.waitDurationInOpenState=10s

#If the failure rate is 50%, then the circuit breaker is transioned to open state.
resilience4j.circuitbreaker.instances.companyBreaker.failureRateThreshold=50

#This registers the health indicator into actuator.
resilience4j.circuitbreaker.instances.companyBreaker.register-health-indicator=true

#This will automatically allow the circuitbreaker to transion it's state from open to half-open
resilience4j.circuitbreaker.instances.companyBreaker.automatic-transition-from-open-to-half-open-enabled=true

#This determines the type of sliding window, the last n calls are recorded and used to calculate
#the failure rate, where n is the size of sliding-window
resilience4j.circuitbreaker.instances.companyBreaker.sliding-window-type=count_based

#This is the default wait time, a thread will wait to acquire permission to run, when the limit is reached.
resilience4j.ratelimiter.instances.companyBreaker.timeout-duration = 0
#It is the period after which the limit is refreshed.
resilience4j.ratelimiter.instances.companyBreaker.limit-refresh-period = 4
#Here the rate limiter will allow 2 calls, every 4 seconds.
resilience4j.ratelimiter.instances.companyBreaker.limit-for-period = 2

#For Retry Mechanism
#The no.of attempts we wil do.
resilience4j.circuitbreaker.instances.companyBreaker.max-attempts=5
#It specifies the duration for which we need to wait before making next call.
resilience4j.circuitbreaker.instances.companyBreaker.wait-duration=2s